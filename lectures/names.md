---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
heading-map:
  overview: مقدمه
  variable-names-in-python: نام‌های متغیر در پایتون
  namespaces: فضاهای نام
  viewing-namespaces: مشاهده فضاهای نام
  interactive-sessions: محیط تعاملی
  the-global-namespace: فضای نام سراسری
  local-namespaces: فضاهای نام محلی
  the-__builtins__-namespace: فضای نام داخلی (The `__builtins__` Namespace )
  name-resolution: Name Resolution
  indexmutable-single-mutable-versus-indeximmutable-single-immutable-parameters: 'پارامترهای {index}`تغییرپذیر <single: Mutable>` در مقابل {index}`تغییرناپذیر <single: Immutable>`'
---

(oop_names)=
```{raw} jupyter
<div id="qe-notebook-header" align="right" style="text-align:right;">
        <a href="https://quantecon.org/" title="quantecon.org">
                <img style="width:250px;display:inline;" width="250px" src="https://assets.quantecon.org/img/qe-menubar-logo.svg" alt="QuantEcon">
        </a>
</div>
```

# نام‌ها و فضاهای نام

## مقدمه

این درس کاملا درباره نام‌ متغیرها است،اینکه چگونه استفاده می‌شوند و مفسر پایتون چگونه آن ها را درک می‌کند.

ممکن است این موضوع کمی خسته‌کننده به نظر برسد، اما مدلی که پایتون برای مدیریت نام‌ها اتخاذ کرده است، ظریف و جالب است.

علاوه بر این، اگر درک خوبی از نحوه کار نام‌ها در پایتون داشته باشید، ساعت‌های زیادی را برای اشکال‌زدایی صرف نخواهید کرد.

(var_names)=
## نام‌های متغیر در پایتون

```{index} single: Python; Variable Names
```

دستور پایتون زیر را در نظر بگیرید:

```{code-cell} python3
x = 42
```

اکنون می‌دانیم که وقتی این دستور اجرا می‌شود، پایتون یک شیء از نوع `int` در حافظه کامپیوتر شما ایجاد می‌کند که شامل موارد زیر است:

* مقدار `42`
* برخی صفات مرتبط

اما خود `x` چیست؟

در پایتون، `x` یک **نام** نامیده می‌شود، و دستور `x = 42` نام `x` را به شیء عدد صحیح که تازه در موردش صحبت کردیم **متصل** می‌کند.

در پشت صحنه، این فرآیند اتصال نام‌ها به اشیاء به عنوان یک دیکشنری پیاده‌سازی می‌شود، که درباره این موضوع در ادامه بیشتر خواهیم گفت.

هیچ مشکلی برای اتصال دو یا چند نام به یک شیء وجود ندارد، صرف‌نظر از اینکه آن شیء چه باشد:

```{code-cell} python3
def f(string):      # Create a function called f
    print(string)   # that prints any string it's passed

g = f
id(g) == id(f)
```

```{code-cell} python3
g('test')
```

در مرحله اول، یک شیء تابع(function object) ایجاد می‌شود و نام `f` به آن متصل(bind) می‌شود.

پس از اتصال نام `g` به همان شیء، می‌توانیم از آن در هر جایی که از `f` استفاده می‌کنیم، استفاده کنیم.

وقتی تعداد نام‌های متصل به یک شیء به صفر می‌رسد، چه اتفاقی می‌افتد؟

در اینجا مثالی از این وضعیت آورده شده است، که در آن نام `x` ابتدا به یک شیء متصل می‌شود و سپس به شیء دیگری **دوباره متصل** می‌شود

```{code-cell} python3
x = 'foo'
id(x)
x = 'bar'  
id(x)
```

در این مورد، پس از اینکه `x` را دوباره به `'bar'` متصل می‌کنیم، دیگر هیچ نامی به شیء اول یعنی `'foo'` متصل نیست.

این وضعیت باعث می‌شود که `'foo'` وارد فرآیند جمع‌آوری زباله (garbage collection) شود.

به عبارت دیگر، جای حافظه‌ای که آن شیء را ذخیره می‌کند، آزاد می‌شود و به سیستم عامل بازگردانده می‌شود.

جمع‌آوری زباله در واقع یکی از حوزه های فعال پژوهشی در علوم کامپیوتر است.

اگر علاقه‌مند هستید، می‌توانید [بیشتر درباره جمع‌آوری زباله بخوانید](https://rushter.com/blog/python-garbage-collector/).

## فضاهای نام

```{index} single: Python; Namespaces
```

در بحث قبلی دستور زیر را نوشتیم:

```{code-cell} python3
x = 42
```

این دستور نام `x` را به عدد صحیح در سمت راست متصل می‌کند.

همچنین ذکر کردیم که این فرآیند اتصال `x` به شیء صحیح به عنوان یک دیکشنری پیاده‌سازی می‌شود.

این دیکشنری، فضای نام نامیده می‌شود.

```{admonition} تعریف
یک **فضای نام** یک جدول از نمادها است که به پایتون می‌گوید هر اسم مربوط به کدام شیء در حافظه است.
```

پایتون از چندین فضای نام استفاده می‌کند و در صورت لزوم آن‌ها را به صورت پویا ایجاد می‌کند.

به عنوان مثال، هر بار که ماژولی را import می‌کنیم، پایتون یک فضای نام برای آن ماژول ایجاد می‌کند.

برای مشاهده این موضوع در عمل، فرض کنید اسکریپتی به نام `mathfoo.py` می‌نویسیم که فقط یک خط دارد:

```{code-cell} python3
%%file mathfoo.py
pi = 'foobar'
```

حالا مفسر پایتون را شروع می‌کنیم و آن را import می‌کنیم:

```{code-cell} python3
import mathfoo
```

بعد بیایید ماژول `math` را از کتابخانه استاندارد import کنیم:

```{code-cell} python3
import math
```

هر دوی این ماژول‌ها یک صفت به نام `pi` دارند:

```{code-cell} python3
math.pi
```

```{code-cell} python3
mathfoo.pi
```

این دو اتصال متفاوت `pi` در دو فضای نام جداگانه وجود دارند و هر کدام به صورت یک دیکشنری پیاده‌سازی شده‌اند.

اگر بخواهید، می‌توانید این دیکشنری را مستقیما با استفاده از `module_name.__dict__` نگاه کنید:

```{code-cell} python3
import math

math.__dict__.items()
```

```{code-cell} python3
import mathfoo

mathfoo.__dict__
```

همان‌طور که می‌دانید، ما به عناصر موجود در فضای نام، با استفاده از نقطه‌گذاری صفات دسترسی پیدا می‌کنیم.

```{code-cell} python3
math.pi
```

این دستور کاملاً معادل `math.__dict__['pi']` است:

```{code-cell} python3
math.__dict__['pi'] 
```

## مشاهده فضاهای نام

همان‌طور که در بالا دیدیم، فضای نام `math` را می‌توان با تایپ کردن `math.__dict__` چاپ (print)کرد.

راه دیگر برای دیدن محتویات آن تایپ کردن `vars(math)` است:

```{code-cell} python3
vars(math).items()
```

اگر فقط می‌خواهید نام‌ها را ببینید، می‌توانید دستور زیر را تایپ کنید:

```{code-cell} python3
# Show the first 10 names
dir(math)[0:10]
```

به نام‌های ویژه `__doc__` و `__name__` توجه کنید.

این‌ نام ها به محض import شدن هر ماژول، به طور خودکار در فضای نام ایجاد و مقداردهی می‌شوند:

* `__doc__` رشته مستندسازی ماژول است
* `__name__` نام ماژول است

```{code-cell} python3
print(math.__doc__)
```

```{code-cell} python3
math.__name__
```

## محیط تعاملی

```{index} single: Python; Interpreter
```

در پایتون، **تمام** کدهایی که توسط مفسر اجرا می‌شوند داخل یک ماژول اجرا می‌شوند.

اما دستوراتی که مستقیما در محیط تعاملی (prompt) تایپ می‌کنیم چطور؟

این‌ دستورها هم به عنوان کدی در نظر گرفته می‌شوند که داخل یک ماژول اجرا می‌شود؛ در این حالت، آن ماژول `__main__` نام دارد.

برای بررسی این موضوع، می‌توانیم مقدار `__name__`را درprompt چاپ کنیم تا نام ماژول فعلی را ببینیم.

```{code-cell} python3
print(__name__)
```

وقتی یک اسکریپت را با استفاده از دستور `run` در IPython اجرا می‌کنیم، محتویات فایل نیز به عنوان بخشی از `__main__` اجرا می‌شوند.

برای مشاهده این موضوع، بیایید یک فایل `mod.py` ایجاد کنیم که صفت `__name__` خودش را چاپ کند:

```{code-cell} ipython
%%file mod.py
print(__name__)
```

حالا بیایید دو روش متفاوت اجرای آن را در IPython ببینیم:

```{code-cell} python3
import mod  # Standard import
```

```{code-cell} ipython
%run mod.py  # Run interactively
```

در حالت دوم، کد به عنوان بخشی از `__main__` اجرا می‌شود، بنابراین `__name__` برابر با `__main__` است.

برای دیدن محتویات فضای نام `__main__` از `()vars` به جای `vars(__main__)` استفاده می‌کنیم.

اگر این کار را در IPython انجام دهید، تعداد زیادی متغیر خواهید دید که IPython به آن‌ها نیاز دارد و هنگام شروع جلسه مقداردهی اولیه را انجام داده است.

اگر ترجیح می‌دهید فقط متغیرهایی که شما مقداردهی اولیه کرده‌اید را ببینید، از `whos%` استفاده کنید:

```{code-cell} ipython
x = 2
y = 3

import numpy as np

%whos
```

## فضای نام سراسری یا جهانی(The Global Namespace)

```{index} single: Python; Namespace (Global)
```

مستندات پایتون اغلب به "فضای نام سراسری" اشاره می‌کند.

فضای نام سراسری *فضای نام ماژولی است که در حال حاضر در حال اجرا است*.

به عنوان مثال، فرض کنید که مفسر را باز می‌کنیم و شروع به انجام تخصیص ها(assignments) می‌کنیم.

اکنون ما در ماژول `__main__` کار می‌کنیم، و از این رو فضای نام برای `__main__` همان فضای نام سراسری است.

سپس، ماژولی به نام `amodule` را import می‌کنیم:

```{code-block} python3
:class: no-execute

import amodule
```

در این نقطه، مفسر یک فضای نام برای ماژول `amodule` ایجاد می‌کند و شروع به اجرای دستورات در ماژول می‌کند.

در حالی که این اتفاق می‌افتد، فضای نام `amodule.__dict__` فضای نام سراسری است.

پس از اتمام اجرای ماژول، مفسر به ماژولی که دستور import از آن صادر شده بود بازمی‌گردد.

در این مثال، این ماژول `__main__` است، بنابراین دوباره فضای نام مربوط به `__main__` به عنوان فضای نام سراسری درنظر گرفته می‌شود.

## فضای نام محلی(Local Namespaces)

```{index} single: Python; Namespace (Local)
```

نکته مهم: وقتی یک تابع را فراخوانی می‌کنیم، مفسر یک *فضای نام محلی* برای آن تابع ایجاد می‌کند و متغیرها را در آن فضای نام ثبت می‌کند.

دلیل این امر در همین لحظه توضیح داده خواهد شد.

متغیرهای موجود در فضای نام محلی *متغیرهای محلی* نامیده می‌شوند.

پس از بازگشت تابع، فضای نام آزاد می‌شود و از بین می‌رود.

در حالی که تابع در حال اجرا است، می‌توانیم محتویات فضای نام محلی را با `()locals` مشاهده کنیم.

به عنوان مثال، دستور زیر را در نظر بگیرید:

```{code-cell} python3
def f(x):
    a = 2
    print(locals())
    return a * x
```

حالا بیایید تابع را فراخوانی کنیم:

```{code-cell} python3
f(1)
```

می‌توانید فضای نام محلی `f` را قبل از نابود شدن ببینید.

## فضای نام داخلی (The `__builtins__` Namespace )

```{index} single: Python; Namespace (__builtins__)
```

ما از توابع داخلی مختلفی مانند `()max` و `()dir` و `()str`و `()list` و `()len` و `()range` و `()type`و غیره، استفاده کرده‌ایم.

اما دسترسی به این نام‌ها چگونه امکان پذیر است؟

* این تعاریف در ماژولی به نام `__builtin__` ذخیره شده‌اند.
* آن‌ها فضای نام مخصوص به خود را دارند که به آن `__builtins__` گفته می‌شود.

```{code-cell} python3
# Show the first 10 names in `__main__`
dir()[0:10]
```

```{code-cell} python3
# Show the first 10 names in `__builtins__`
dir(__builtins__)[0:10]
```

می‌توانیم به عناصر فضای نام به صورت زیر دسترسی پیدا کنیم:

```{code-cell} python3
__builtins__.max
```

اما `__builtins__` خاص است، چون همیشه می‌توانیم مستقیماً به آن‌ها هم دسترسی داشته باشیم.

```{code-cell} python3
max
```

```{code-cell} python3
__builtins__.max == max
```

بخش بعدی توضیح می‌دهد که این کار چگونه امکان پذیر است ...

## Name Resolution

```{index} single: Python; Namespace (Resolution)
```

فضاهای نام عالی هستند زیرا به ما کمک می‌کنند تا نام‌های متغیر را سازماندهی کنیم.

(در prompt عبارت `import this` را تایپ کنید و به آخرین موردی که چاپ می‌شود نگاه کنید)

با این حال، ما باید بفهمیم که مفسر پایتون چگونه با فضاهای نام متعدد کار می‌کند.

درک جریان اجرا به ما کمک می‌کند تا بررسی کنیم که کدام متغیرها در دسترس هستند و چگونه می‌توانیم هنگام نوشتن و اشکال‌زدایی برنامه‌ها با آن‌ها کار کنیم.

در هر نقطه از اجرای برنامه، در واقع حداقل دو فضای نام وجود دارند که می‌توان به طور مستقیم به آن‌ها دسترسی داشت.

("دسترسی مستقیم" به معنای بدون استفاده از نقطه است، مانند `pi` به جای `math.pi`)

این فضاهای نام عبارتند از:

* فضای نام سراسری (ماژولی که در حال اجرا است)
* فضای نام داخلی یا builtin

اگر مفسر در حال اجرای یک تابع باشد، آنگاه فضاهای نامی که مستقیما قابل دسترسی هستند، عبارتند از:

* فضای نام محلی تابع
* فضای نام سراسری (ماژولی که در حال اجرا است)
* فضای نام داخلی یا builtin

گاهی اوقات توابع در داخل توابع دیگر تعریف می‌شوند، مانند مثال زیر:

```{code-cell} python3
def f():
    a = 2
    def g():
        b = 4
        print(a * b)
    g()
```

در اینجا `f` تابع *بستار یا دربرگیرنده* برای `g` است و هر تابع فضای نام خود را دارد.

حالا می‌توانیم قانون نحوه کار Name Resolution را در فضای نام توضیح دهیم:

ترتیبی که مفسر برای جستجوی نام‌ها دنبال می‌کند عبارت است از:

1. فضای نام محلی (اگر وجود داشته باشد)
1. زنجیره فضاهای نام توابع بستار (اگر وجود داشته باشند)
1. فضای نام سراسری
1. فضای نام داخلی یا builtin

اگر نام در هیچ یک از این فضاهای نام نباشد، مفسر یک `NameError` ایجاد می‌کند.

این قانون **LEGB** نامیده می‌شود (local, enclosing, global, builtin).

در ادامه یک مثال برای روشن شدن موضوع آورده شده است.

تصاویر و نمودارهای این مثال توسط [nbtutor](https://github.com/lgpage/nbtutor) در یک ژوپیترنوت‌بوک  ایجاد شده‌اند.

آن‌ها می‌توانند به شما کمک کنند تا برنامه خود را بهتر درک کنید، مخصوصا زمانی که در حال یادگیری یک زبان برنامه نویسی جدید هستید.

فرض کنید اسکریپتی به نام `test.py` داریم که به صورت زیر است:

```{code-cell} python3
%%file test.py
def g(x):
    a = 1
    x = x + a
    return x

a = 0
y = g(10)
print("a = ", a, "y = ", y)
```

وقتی این اسکریپت را اجرا می‌کنیم، چه اتفاقی می‌افتد؟

```{code-cell} ipython
%run test.py
```

ابتدا:

* فضای نام سراسری با مقدار `{}` ایجاد می‌شود.

```{figure} /_static/lecture_specific/oop_intro/global.png
```

* یک تابع ساخته می‌شود و نام `g` در فضای نام سراسری به آن متصل می‌شود.
* نام `a`هم در فضای سراسری به مقدار  `0` متصل می‌شود.

```{figure} /_static/lecture_specific/oop_intro/global2.png
```

سپس `g` از طریق `y = g(10)` فراخوانی می‌شود که منجر به دنباله ای از اقدامات زیر می‌شود:

* فضای نام محلی برای تابع ایجاد می‌شود.
* نام‌های محلی `x` و `a` متصل می‌شوند، به طوری که فضای نام محلی به `{'x': 10, 'a': 1}` تبدیل می‌شود.

توجه کنید که فضای نام سراسری `a` تحت تأثیر فضای نام محلی `a` قرار نگرفت.

```{figure} /_static/lecture_specific/oop_intro/local1.png
```

* دستور `x = x + a` از نام های محلی `a` و `x` برای محاسبه `x + a` استفاده می‌کند و نام محلی `x` به نتیجه آن متصل می‌کند.
* این مقدار بازگردانده می‌شود و نام `y` در فضای نام سراسری به آن متصل می‌شود.
* `x` و `a` محلی حذف می‌شوند (و فضای نام محلی آزاد می‌شود).

```{figure} /_static/lecture_specific/oop_intro/local_return.png
```

(mutable_vs_immutable)=
### پارامترهای {index}`تغییرپذیر <single: Mutable>` در مقابل {index}`تغییرناپذیر <single: Immutable>`

این زمان خوبی است که کمی بیشتر درباره اشیاء تغییرپذیر و تغییرناپذیر صحبت کنیم.

فرض کنید قطعه کد زیر را داریم:

```{code-cell} python3
def f(x):
    x = x + 1
    return x

x = 1
print(f(x), x)
```

اکنون می‌فهمیم که اینجا چه اتفاقی می‌افتد: کد مقدار `2` را به عنوان خروجی `f(x)` و مقدار `1` را به عنوان مقدار `x` چاپ می‌کند.

ابتدا `f` و `x` در فضای نام سراسری ثبت می‌شوند.

فراخوانی `f(x)` یک فضای نام محلی ایجاد می‌کند و `x` را به آن اضافه می‌کند که به `1` متصل است.

سپس، این `x` محلی دوباره به شیء عدد صحیح جدید `2` متصل می‌شود و این مقدار بازگردانده می‌شود.

هیچ یک از تغییرات، بر `x` سراسری تأثیر نمی‌گذارد.

با این حال، وقتی از یک نوع داده **تغییرپذیر** مانند لیست استفاده می‌کنیم، داستان متفاوت است:

```{code-cell} python3
def f(x):
    x[0] = x[0] + 1
    return x

x = [1]
print(f(x), x)
```

این کد `[2]` را به عنوان مقدار `f(x)` چاپ می‌کند و *همان* مقدار برای `x` سراسری هم نمایش داده می‌شود.

در اینجا چه اتفاقی می‌افتد:

* `f` به عنوان یک تابع در فضای نام سراسری ثبت می‌شود

```{figure} /_static/lecture_specific/oop_intro/mutable1.png
```

* `x` به `[1]` در فضای نام سراسری متصل می‌شود

```{figure} /_static/lecture_specific/oop_intro/mutable2.png
```

* فراخوانی `f(x)`:
    * یک فضای نام محلی ایجاد می‌کند
    * `x` را به فضای نام محلی اضافه می‌کند که به `[1]` متصل است

```{figure} /_static/lecture_specific/oop_intro/mutable3.png
```

```{note}
`x` سراسری و `x` محلی به همان لیست `[1]` اشاره می‌کنند.
```

می‌توانیم ببینیم که شناسه `x` محلی و `x` سراسری یکسان است.

```{code-cell} python3
def f(x):
    x[0] = x[0] + 1
    print(f'the identity of local x is {id(x)}')
    return x

x = [1]
print(f'the identity of global x is {id(x)}')
print(f(x), x)
```

* در داخل `f(x)`:
    * لیست `[1]` به `[2]` تغییر می‌کند
    * لیست `[2]` بازگردانده می‌شود.

```{figure} /_static/lecture_specific/oop_intro/mutable4.png
```
* فضای نام محلی آزاد می‌شود و `x` محلی از بین می‌رود

```{figure} /_static/lecture_specific/oop_intro/mutable5.png
```

اگر می‌خواهید `x` محلی و `x` سراسری را به طور جداگانه تغییر دهید، می‌توانید یک نسخه [*کپی*](https://docs.python.org/3/library/copy.html) از لیست بسازید و آن نسخه کپی را به `x` محلی اختصاص دهید.

این مورد را به عنوان تمرین به شما می‌سپاریم تا بررسی کنید.