---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
heading-map:
  overview: مقدمه
  objects: اشیاء
  type: نوع
  identity: شناسه
  object-content-data-and-attributes: 'محتوای شیء: داده‌ها و ویژگی‌ها'
  methods: متدها
  inspection-using-rich: بازرسی با استفاده از Rich
  a-little-mystery: یک معمای کوچک
  summary: خلاصه
  exercises: تمرین‌ها
---

(oop_intro)=
```{raw} jupyter
<div id="qe-notebook-header" align="right" style="text-align:right;">
        <a href="https://quantecon.org/" title="quantecon.org">
                <img style="width:250px;display:inline;" width="250px" src="https://assets.quantecon.org/img/qe-menubar-logo.svg" alt="QuantEcon">
        </a>
</div>
```

# برنامه‌نویسی شی‌گرا قسمت اول : اشیاء و متدها

## مقدمه

در گذشته، بیشتر زبان های برنامه‌نویسی مانند (Fortran، C، MATLAB و غیره) بر اساس پارادایمی به نام «برنامه‌نویسی [رویه‌ای](https://en.wikipedia.org/wiki/Procedural_programming)» طراحی شده بودند. در این پارادایم، برنامه به صورت مجموعه‌ای از دستورالعمل ها و توابع نوشته می‌شود که به ترتیب اجرا شده و داده‌ها را پردازش می‌کند.

این پارادایم به شرح زیر عمل می‌کند:

* برنامه دارای یک وضعیت است که متناظر با مقادیر متغیرهای خود است.
* توابع فراخوانی می‌شوند تا بر روی این وضعیت عمل کرده و آن را تغییر دهند.
* خروجی‌های نهایی از طریق دنباله‌ای از فراخوانی‌های توابع تولید می‌شوند.

دو پارادایم مهم دیگر، [برنامه‌نویسی شی‌گرا](https://en.wikipedia.org/wiki/Object-oriented_programming) (OOP) و [برنامه‌نویسی تابعی](https://en.wikipedia.org/wiki/Functional_programming) هستند.

در پارادایم OOP، داده‌ها و توابع در قالب "اشیاء" با یکدیگر ترکیب می‌شوند، و توابع در این زمینه به عنوان **متدها** شناخته می‌شوند.

متدها برای تغییر داده‌های موجود در شیء فراخوانی می‌شوند.

* به یک لیست پایتون فکر کنید که حاوی داده است و متدهایی مانند `()append` و `()pop` دارد که داده را تغییر می‌دهند.

زبان‌های برنامه‌نویسی تابعی، بر اساس ایده ترکیب توابع ساخته شده‌اند.

* نمونه‌های معروف این دسته شامل [Lisp](https://en.wikipedia.org/wiki/Common_Lisp)، [Haskell](https://en.wikipedia.org/wiki/Haskell) و [Elixir](https://en.wikipedia.org/wiki/Elixir_(programming_language)) هستند.

پس پایتون در کدام یک از این دسته‌ها قرار می‌گیرد؟

در واقع پایتون یک زبان عمل‌گرا است که به جای پیروی سخت گیرانه از یک رویکرد خالص، سبک‌های شی‌گرا، تابعی و رویه‌ای را با یکدیگر ترکیب می‌کند.

از یک طرف، این ویژگی به پایتون و کاربرانش اجازه می‌دهد تا جنبه‌های خوب پارادایم‌های مختلف را انتخاب کنند.

و از طرف دیگر، همین نبود خلوص پارادایمی ممکن است گاهی اوقات منجر به برخی سردرگمی‌ها شود.

خوشبختانه اگر بدانیم که در سطح بنیادی، پایتون یک زبان شی‌گرا *است*، این سردرگمی تا حد زیادی به حداقل می‌رسد.

منظور ما این است که، در پایتون، *همه چیز یک شیء است*.

در این درس، توضیح می‌دهیم که این گزاره به چه معناست و چرا اهمیت دارد.

ما از کتابخانه خارجی زیر استفاده خواهیم کرد:

```{code-cell} python3
:tags: [hide-output]
!pip install rich
```

## اشیاء

```{index} single: Python; Objects
```

در پایتون، یک *شیء* مجموعه‌ای از داده‌ها و دستورالعمل‌های نگهداری‌شده در حافظه کامپیوتر است که شامل موارد زیر می‌شود:

1. یک نوع(Type)
1. یک شناسه منحصر به فرد(Unique Identity)
1. داده (یعنی محتوا)
1. متدها(Methods)

این مفاهیم به ترتیب تعریف و بررسی می‌شوند.

(type)=
### نوع (Type)

```{index} single: Python; Type
```

پایتون انواع مختلفی از اشیاء را فراهم می‌کند تا بتواند دسته‌های مختلفی از داده ها را پشتیبانی کند.

به عنوان مثال:

```{code-cell} python3
s = 'This is a string'
type(s)
```

```{code-cell} python3
x = 42   # حالا بیایید یک عدد صحیح ایجاد کنیم
type(x)
```

نوع یک شیء برای بسیاری از عبارات مهم است.

به عنوان مثال، عملگر جمع بین دو رشته متنی به معنای به هم پیوند دادن آنها است:

```{code-cell} python3
'300' + 'cc'
```

از طرف دیگر، بین دو عدد به معنای جمع معمولی است:

```{code-cell} python3
300 + 400
```

عبارت زیر را در نظر بگیرید:

```{code-cell} python3
---
tags: [raises-exception]
---
'300' + 400
```

در اینجا ما در حال ترکیب انواع متفاوتی از مقادیر هستیم، و برای پایتون مشخص نیست که آیا کاربر می‌خواهد:

* `'300'` را به عدد صحیح تبدیل کند و سپس آن را به `400` اضافه کند، یا
* `400` را به رشته تبدیل کند و سپس آن را به `'300'` متصل کند.

برخی زبان‌ها ممکن است سعی کنند حدس بزنند، اما پایتون یک زبان *تایپ قوی (strongly typed)* است.

* نوع داده اهمیت زیادی دارد و تبدیل ضمنی نوع در پایتون به ندرت انجام می‌شود.
* در نتیجه پایتون به جای حدس زدن، با نشان دادن یک خطای `TypeError` پاسخ می‌دهد.

برای جلوگیری از این خطا، باید با تغییر نوع داده مربوطه، منظور خود را به صورت صریح وشفاف مشخص کنید.

به عنوان مثال:

```{code-cell} python3
int('300') + 400   # برای جمع به عنوان اعداد، رشته را به عدد صحیح تبدیل کنید
```

(identity)=
### شناسه (Unique Identity)

```{index} single: Python; Identity
```

در پایتون، هر شیء یک شناسه منحصر به فرد دارد که به پایتون (و ما) کمک می‌کند تا شیء را ردیابی و تشخیص دهیم.

شناسه یک شیء را می‌توان از طریق تابع `()id` به دست آورد:

```{code-cell} python3
y = 2.5
z = 2.5
id(y)
```

```{code-cell} python3
id(z)
```

در این مثال، `y` و `z` با اینکه مقدار یکسانی (یعنی `2.5`) دارند، اما آن‌ها یک شیء نیستند.

شناسه یک شیء در واقع فقط آدرس شیء در حافظه است.

### محتوای شیء: داده‌ها و ویژگی‌ها

```{index} single: Python; Content
```

اگر `x = 42` را قرار دهیم، یک شیء از نوع `int` ایجاد می‌کنیم که حاوی داده `42` است.

در واقع، همانطور که مثال زیر نشان می‌دهد، حاوی اطلاعات بیشتری نیز هست:
```{code-cell} python3
x = 42
x
```

```{code-cell} python3
x.imag
```

```{code-cell} python3
x.__class__
```

وقتی پایتون این شیء که از نوع عدد صحیح است را ایجاد می‌کند، اطلاعات کمکی مختلفی مانند قسمت موهومی(imaginary) و نوع(type) شیء را با آن ذخیره می‌کند.

هر نامی که بعد از نقطه بیاید *ویژگی(attribute)* شیء سمت چپ نقطه نامیده می‌شود.

* به عنوان مثال، `imag` و `__class__` ویژگی‌های `x` هستند.

از این مثال می‌بینیم که اشیاء دارای ویژگی‌هایی هستند که حاوی اطلاعات کمکی هستند.

 همچنین، ویژگی‌هایی وجود دارند که مانند توابع عمل می‌کنند و *متد(methods)* نامیده می‌شوند

این ویژگی‌ها مهم هستند، بنابراین بیایید آن‌ها را به طور عمیق بررسی کنیم.

(methods)=
### متدها

```{index} single: Python; Methods
```

متدها *توابعی هستند که به طور مستقیم با یک شیء مرتبط شده و جزئی از آن شیء محسوب می‌شوند*.

به طور رسمی، متدها ویژگی‌های اشیاء هستند که **قابل فراخوانی** هستند، یعنی ویژگی‌هایی که می‌توان آن ها را مانند توابع فراخوانی کرد.

```{code-cell} python3
x = ['foo', 'bar']
callable(x.append)
```

```{code-cell} python3
callable(x.__doc__)
```

متدها معمولاً بر روی داده‌های موجود در شیئی که به آن تعلق دارند عمل می‌کنند، یا آن داده را با داده‌های دیگر ترکیب می‌کنند:

```{code-cell} python3
x = ['a', 'b']
x.append('c')
s = 'This is a string'
s.upper()
```

```{code-cell} python3
s.lower()
```

```{code-cell} python3
s.replace('This', 'That')
```

بخش بزرگی از قابلیت‌های پایتون حول فراخوانی‌های متدها سازماندهی شده است.

به عنوان مثال، کد زیر را در نظر بگیرید:

```{code-cell} python3
x = ['a', 'b']
x[0] = 'aa'  # تغییر آیتم با استفاده از براکت
x
```

با اینکه به نظر می‌رسد که در اینجا از هیچ متدی استفاده نشده باشد، اما در واقع استفاده از براکت ها برای تغییر دادن مقادیر فقط یک رابط ساده و راحت برای فراخوانی یک متد است.

آنچه در واقع اتفاق می‌افتد این است که پایتون متد `__setitem__` را به شرح زیر فراخوانی می‌کند:

```{code-cell} python3
x = ['a', 'b']
x.__setitem__(0, 'aa')  # معادل x[0] = 'aa'
x
```

(اگر بخواهید می‌توانید متد `__setitem__` را تغییر دهید، به طوری که استفاده از براکت ها برای مقادیر کار کاملاً متفاوتی انجام دهد)

## بازرسی با استفاده از Rich

یک بسته بسیار کاربردی به نام [rich](https://github.com/Textualize/rich) وجود دارد که به ما کمک می‌کند محتویات یک شیء را به صورت خوانا مشاهده کنیم.

به عنوان مثال:

```{code-cell} python3
from rich import inspect
x = 10
inspect(10)
```
برای دیدن متدها هم میتوانیم از این روش استفاده کنیم:
```{code-cell} python3
inspect(10, methods=True)
```

در واقع متدهای بیشتری هم وجود دارند، و شما می‌توانید با اجرای `inspect(10, all=True)` آنها را مشاهده کنید.

## یک معمای کوچک

در این سخنرانی ادعا کردیم که پایتون، در ذات خود یک زبان شی‌گرا است.

اما در اینجا مثالی وجود دارد که بیشتر رویه‌ای به نظر می‌رسد:

```{code-cell} python3
x = ['a', 'b']
m = len(x)
m
```

اگر پایتون شی‌گرا است، چرا از `()x.len` استفاده نمی‌کنیم؟

پاسخ به این نکته مربوط می‌شود به اینکه پایتون به قابلیت خوانایی و سبک ثابت و یکسان اهمیت می‌دهد.

در پایتون، معمولا کاربران اشیاء سفارشی می‌سازند، ما نیز نحوه انجام این کار را {doc}`بعداً <python_oop>` بررسی خواهیم.

معمولا کاربران متدهایی به اشیاء خود اضافه می‌کنند که طول شیء را، به طوریکه برای شیء مناسب باشد، اندازه‌گیری کنند.

هنگام نام‌گذاری چنین متدی، انتخاب‌های طبیعی `()len` و `()length` هستند.

اگر برخی از کاربران `()len` و برخی دیگر `()length` را انتخاب کنند، سبک ناسازگار و ناهماهنگ شده و به خاطر سپردن آن سخت تر خواهد بود.

برای جلوگیری از این امر، سازنده پایتون تصمیم گرفت `()len` را به عنوان یک تابع داخلی اضافه کند، تا تأکید کند بر اینکه استفاده از `()len` قراردادی است.

حالا، با گفتن همه این‌ها، پایتون همچنان در پشت صحنه شی‌گرا *است*.

در واقع، لیست `x` که پیشتر بررسی شد، دارای متدی به نام `()__len__` است.

و تنها کاری که تابع `()len` انجام می‌دهد فراخوانی این متد است.

به عبارت دیگر، معادل کد زیر  است:

```{code-cell} python3
x = ['a', 'b']
len(x)
```
و

```{code-cell} python3
x = ['a', 'b']
x.__len__()
```

## خلاصه

نکته اصلی این درس این است:

* در پایتون، *همه چیز در حافظه به عنوان یک شیء در نظر گرفته می‌شود*.

و این فقط شامل لیست‌ها، رشته‌ها و غیره نیست، بلکه مواردی که کمتر مورد توجه قرار میگیرد را نیز شامل می‌شود، مانند:

* توابع (پس از بارگذاری در حافظه)
* ماژول‌ها
* فایل‌های باز شده برای خواندن یا نوشتن
* اعداد صحیح و غیره

به یاد داشتن اینکه همه چیز یک شیء است به شما کمک می‌کند تا با برنامه‌های خود تعامل داشته باشید و کد پایتونی واضحی بنویسید.

## تمرین‌ها

```{exercise-start}
:label: oop_intro_ex1
```

ما قبلاً با {any}`نوع داده بولین <boolean>` آشنا شدیم.

با استفاده از آنچه در این درس آموختیم، لیستی از متدهای شیء بولین `True` را چاپ کنید.

```{hint}
:class: dropdown

می‌توانید از `callable()` برای آزمایش اینکه آیا یک ویژگی از یک شیء می‌تواند به عنوان تابع فراخوانی شود، استفاده کنید
```

```{exercise-end}
```

```{solution-start} oop_intro_ex1
:class: dropdown
```

ابتدا، باید همه ویژگی‌های `True` را پیدا کنیم، که با کد زیر میتوانید پیدا کنید:

```{code-cell} python3
print(sorted(True.__dir__()))
```

یا

```{code-cell} python3
print(sorted(dir(True)))
```

از آنجایی که نوع داده بولین یک نوع  داده اولیه است، می‌توانید آن را در مجموعه پیش فرض توابع و نام ها (built-in) نیز پیدا کنید:

```{code-cell} python3
print(dir(__builtins__.bool))
```

در اینجا از یک حلقه `for` برای فیلتر کردن ویژگی‌هایی که قابل فراخوانی هستند استفاده می‌کنیم:

```{code-cell} python3
attributes = dir(__builtins__.bool)
callablels = []

for attribute in attributes:
  # از eval() برای ارزیابی یک رشته به عنوان یک عبارت استفاده کنید
  if callable(eval(f'True.{attribute}')):
    callablels.append(attribute)
print(callablels)
```

```{solution-end}
```